<!-- 
README: Simulação Visual de Buraco Negro como Tesseract 4D

Uso:
- Abra este arquivo em um navegador moderno (Chrome, Firefox, etc.) com suporte a WebGL2.
- Controles:
  - Mouse drag: Rotaciona a cena em 3D.
  - Mouse wheel: Zoom in/out.
  - Teclas:
    - Espaço: Pausa/retoma animação.
    - 1: Preset Tesseract básico.
    - 2: Foco no horizonte (aumenta lente).
    - 3: Visão com disco de acreção.
    - Q/W: Diminui/aumenta qualidade (baixa/média/alta).
    - A/S: Diminui/aumenta intensidade da lente.
    - Z/X: Diminui/aumenta brilho do disco.
    - C/V: Diminui/aumenta velocidade de rotação 4D.
  - A cena é responsiva e ajusta ao redimensionar a janela.

Compatibilidade:
- Requer WebGL2; fallback para WebGL1 se disponível, mas com shaders simplificados.
- Testado em desktops; pode ser lento em mobile devido a raymarching.
- Ajuste parâmetros via uniforms no código JS se necessário.

Ajustes:
- Edite uniforms no JS (ex.: lensStrength inicial).
- Para debug FPS: Descomente a seção de FPS no loop de animação.

Aproximações Físicas:
- Projeção 4D→3D: Rotação 4D via matrizes e projeção perspectiva simplificada.
- Lente Gravitacional: Deflexão radial simples ∝ 1/r^2, não GR completa.
- Disco de Acreção: Anel plano com brilho e shift de cor falso.

Licença: MIT License

Copyright (c) 2025 [Seu Nome ou Grok]

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulação de Buraco Negro como Tesseract 4D</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; font-family: Arial; background: rgba(0,0,0,0.5); padding: 10px; }
        #fps { position: absolute; bottom: 10px; right: 10px; color: white; }
    </style>
</head>
<body>
    <canvas id="glcanvas"></canvas>
    <div id="ui">
        <p>Qualidade: <span id="quality">Média</span></p>
        <p>Lente: <span id="lens">1.0</span></p>
        <p>Brilho Disco: <span id="accretion">1.0</span></p>
        <p>Rotação 4D: <span id="rotation">0.1</span></p>
    </div>
    <div id="fps"></div>
    <script>
        // Código JavaScript principal
        const canvas = document.getElementById('glcanvas');
        let gl = canvas.getContext('webgl2');
        let isWebGL2 = true;
        if (!gl) {
            gl = canvas.getContext('webgl');
            isWebGL2 = false;
            console.warn('Fallback para WebGL1');
        }
        if (!gl) {
            alert('Seu navegador não suporta WebGL');
            throw new Error('WebGL não suportado');
        }

        // Ajuste responsivo
        function resizeCanvas() {
            canvas.width = window.innerWidth * devicePixelRatio;
            canvas.height = window.innerHeight * devicePixelRatio;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Vertex Shader (simples, fullscreen quad)
        const vertexShaderSource = isWebGL2 ? `#version 300 es
            in vec4 a_position;
            void main() {
                gl_Position = a_position;
            }
        ` : `#version 100
            attribute vec4 a_position;
            void main() {
                gl_Position = a_position;
            }
        `;

        // Fragment Shader (complexo, com raymarching)
        const fragmentShaderSource = isWebGL2 ? `#version 300 es
            precision highp float;
            out vec4 fragColor;

            uniform float u_time;
            uniform vec2 u_resolution;
            uniform vec2 u_mouse;
            uniform float u_quality; // 0.5 baixa, 1.0 media, 2.0 alta
            uniform float u_lensStrength;
            uniform float u_accretionIntensity;
            uniform int u_projectionMode; // 0: tesseract, 1: horizonte, 2: disco

            // Funções auxiliares

            // Rotação 4D (em planos XY, XZ, etc.)
            mat4 rotation4D(float angle) {
                float c = cos(angle);
                float s = sin(angle);
                return mat4(
                    c, -s, 0., 0.,
                    s, c, 0., 0.,
                    0., 0., c, -s,
                    0., 0., s, c
                ); // Exemplo: rotação em plano XY e WZ
            }

            // Projeção 4D para 3D (perspectiva simples)
            // Comentário: A projeção 4D→3D é feita via divisão perspectiva, similar a 3D→2D.
            // Usamos uma distância de projeção em W (ex.: 2.0 unidades).
            // Isso projeta o ponto 4D (x,y,z,w) para 3D (x/(1 + w/d), y/(1 + w/d), z/(1 + w/d)) onde d é distância.
            vec3 project4DTo3D(vec4 p4, float dist) {
                float factor = dist / (dist - p4.w); // Projeção perspectiva
                return p4.xyz * factor;
            }

            // Signed Distance Field para Tesseract projetado
            // Comentário: O tesseract é definido como max das coordenadas absolutas em 4D.
            // sdf = max(|x|,|y|,|z|,|w|) - size/2.
            // Projetamos os vértices e usamos convex hull aproximado em 3D para SDF.
            // Aproximação: Para simplicidade, projetamos o ponto de raymarch para 4D inverso (mas isso é caro), então usamos SDF 4D e ajustamos.
            float sdfTesseract(vec4 p, float size) {
                vec4 q = abs(p) - vec4(size);
                return length(max(q, 0.0)) + min(max(q.x, max(q.y, max(q.z, q.w))), 0.0);
            }

            // Raymarching com lente gravitacional
            // Comentário: Modelo simplificado de lente: Durante o marching, se próximo ao centro (r < horizon),
            // curvamos a direção do raio adicionando uma aceleração radial ∝ -1/r^2 * lensStrength.
            // Isso simula deflexão gravitacional sem resolver equações diferenciais completas (aproximação newtoniana).
            // Aproximação física: Não é GR (Schwarzschild), mas visualmente convincente para distorção.
            vec3 raymarch(vec3 ro, vec3 rd, float maxDist) {
                float t = 0.0;
                int steps = int(100.0 * u_quality); // Ajusta passos por qualidade
                float horizon = 1.0; // Raio do "horizonte"
                for (int i = 0; i < steps; i++) {
                    vec3 pos = ro + t * rd;
                    // Aplica deflexão se próximo ao centro
                    float r = length(pos);
                    if (r < horizon * 10.0 && u_lensStrength > 0.0) {
                        vec3 accel = -normalize(pos) * u_lensStrength / (r * r + 0.01); // Deflexão ∝ 1/r^2
                        rd += accel * 0.01 * u_quality; // Passo pequeno
                        rd = normalize(rd); // Renormaliza
                    }
                    // SDF no espaço 3D, mas para tesseract, precisamos projetar
                    // Aqui, para simplificar, assumimos projeção prévia; em prática, rotacionamos em 4D.
                    vec4 p4 = vec4(pos, sin(u_time * 0.1)); // Adiciona W temporal para animação 4D
                    p4 = rotation4D(u_time * 0.05) * p4; // Rotação 4D
                    vec3 p3 = project4DTo3D(p4, 2.0);
                    float dist = length(p3) - 0.5; // SDF simples esfera por agora; substituir por tesseract real
                    // TODO: Implementar SDF tesseract projetado melhor
                    if (dist < 0.001) {
                        return pos; // Hit
                    }
                    t += dist * 0.5 / u_quality; // Ajusta passo por qualidade
                    if (t > maxDist) break;
                }
                return ro + t * rd;
            }

            // Disco de acreção simples
            // Comentário: Simula um anel plano em XY, com brilho emissivo e shift de cor falso (vermelho/azul por velocidade).
            // Aproximação: Não simula rotação relativística completa, apenas gradiente de cor.
            float accretionDisk(vec3 pos) {
                float r = length(pos.xz);
                float theta = atan(pos.z, pos.x);
                float brightness = u_accretionIntensity * exp(-abs(r - 1.5) / 0.2); // Anel em r=1.5
                float doppler = sin(theta + u_time); // Falso shift
                return brightness * (1.0 + 0.5 * doppler);
            }

            // Main
            void main() {
                vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution) / u_resolution.y;
                vec3 ro = vec3(0., 0., -3.0); // Camera
                vec3 rd = normalize(vec3(uv, 1.0));

                // Rotação via mouse
                float rx = u_mouse.y * 3.14;
                float ry = u_mouse.x * 6.28;
                mat3 rotX = mat3(1.,0.,0., 0.,cos(rx),-sin(rx), 0.,sin(rx),cos(rx));
                mat3 rotY = mat3(cos(ry),0.,sin(ry), 0.,1.,0., -sin(ry),0.,cos(ry));
                rd = rotY * rotX * rd;
                ro = rotY * rotX * ro;

                // Raymarch
                vec3 hit = raymarch(ro, rd, 20.0);

                // Cor básica
                vec3 col = vec3(0.0);
                if (length(hit) < 10.0) {
                    col = vec3(0.5 + 0.5 * sin(hit)); // Cor simples
                } else {
                    col = vec3(0.1); // Fundo
                }

                // Adiciona disco se mode 2
                if (u_projectionMode == 2) {
                    float acc = accretionDisk(hit);
                    col += vec3(1.0, 0.5, 0.2) * acc;
                }

                // Bloom falso
                col = col + 0.1 * pow(col, vec3(4.0));

                // Presets de cor
                if (u_projectionMode == 0) {
                    col *= vec3(0.2, 0.3, 0.8); // Azul/roxo
                } else if (u_projectionMode == 1) {
                    col *= vec3(0.8, 0.2, 0.3); // Vermelho
                }

                fragColor = vec4(col, 1.0);
            }
        ` : `#version 100
            precision mediump float;

            // Similar, mas simplificado para GLSL 1.00 (remover features WebGL2)
            // ... (adaptar o código acima, removendo out fragColor, usando gl_FragColor, etc.)
            // Para brevidade, usar placeholder; em produção, adaptar.
            void main() {
                gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Placeholder vermelho para fallback
            }
        `;

        // Compilar shaders
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(program));
        }

        gl.useProgram(program);

        // Quad fullscreen
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        // Uniforms
        const timeLoc = gl.getUniformLocation(program, 'u_time');
        const resLoc = gl.getUniformLocation(program, 'u_resolution');
        const mouseLoc = gl.getUniformLocation(program, 'u_mouse');
        const qualityLoc = gl.getUniformLocation(program, 'u_quality');
        const lensLoc = gl.getUniformLocation(program, 'u_lensStrength');
        const accretionLoc = gl.getUniformLocation(program, 'u_accretionIntensity');
        const modeLoc = gl.getUniformLocation(program, 'u_projectionMode');

        // Valores iniciais
        let time = 0;
        let paused = false;
        let mouse = {x: 0, y: 0, down: false, prevX: 0, prevY: 0};
        let rotation = {x: 0, y: 0};
        let zoom = 1.0;
        let quality = 1.0; // Media
        let lensStrength = 1.0;
        let accretionIntensity = 1.0;
        let rotationSpeed = 0.1; // Para rotação 4D
        let projectionMode = 0;

        // UI elements
        const qualitySpan = document.getElementById('quality');
        const lensSpan = document.getElementById('lens');
        const accretionSpan = document.getElementById('accretion');
        const rotationSpan = document.getElementById('rotation');

        function updateUI() {
            qualitySpan.textContent = quality === 0.5 ? 'Baixa' : quality === 1.0 ? 'Média' : 'Alta';
            lensSpan.textContent = lensStrength.toFixed(1);
            accretionSpan.textContent = accretionIntensity.toFixed(1);
            rotationSpan.textContent = rotationSpeed.toFixed(1);
        }
        updateUI();

        // Eventos
        canvas.addEventListener('mousedown', e => {
            mouse.down = true;
            mouse.prevX = e.clientX;
            mouse.prevY = e.clientY;
        });
        window.addEventListener('mouseup', () => mouse.down = false);
        canvas.addEventListener('mousemove', e => {
            if (mouse.down) {
                let dx = (e.clientX - mouse.prevX) / canvas.width;
                let dy = (e.clientY - mouse.prevY) / canvas.height;
                rotation.y += dx * 2;
                rotation.x += dy * 2;
                mouse.prevX = e.clientX;
                mouse.prevY = e.clientY;
            }
            mouse.x = e.clientX / canvas.width * 2 - 1;
            mouse.y = 1 - e.clientY / canvas.height * 2;
        });
        canvas.addEventListener('wheel', e => {
            zoom *= (1 + e.deltaY * 0.001);
            zoom = Math.max(0.1, Math.min(zoom, 10));
        });
        window.addEventListener('keydown', e => {
            switch (e.key) {
                case ' ':
                    paused = !paused;
                    break;
                case '1':
                    projectionMode = 0;
                    break;
                case '2':
                    projectionMode = 1;
                    lensStrength = 2.0;
                    updateUI();
                    break;
                case '3':
                    projectionMode = 2;
                    accretionIntensity = 2.0;
                    updateUI();
                    break;
                case 'q':
                    quality = Math.max(0.5, quality - 0.5);
                    updateUI();
                    break;
                case 'w':
                    quality = Math.min(2.0, quality + 0.5);
                    updateUI();
                    break;
                case 'a':
                    lensStrength = Math.max(0, lensStrength - 0.5);
                    updateUI();
                    break;
                case 's':
                    lensStrength += 0.5;
                    updateUI();
                    break;
                case 'z':
                    accretionIntensity = Math.max(0, accretionIntensity - 0.5);
                    updateUI();
                    break;
                case 'x':
                    accretionIntensity += 0.5;
                    updateUI();
                    break;
                case 'c':
                    rotationSpeed = Math.max(0, rotationSpeed - 0.05);
                    updateUI();
                    break;
                case 'v':
                    rotationSpeed += 0.05;
                    updateUI();
                    break;
            }
        });

        // Loop de animação
        let lastTime = 0;
        let fps = 0;
        const fpsDiv = document.getElementById('fps');
        function animate(now) {
            requestAnimationFrame(animate);
            if (paused) return;

            // FPS debug (opcional, descomente se quiser)
            // fps = 1000 / (now - lastTime);
            // fpsDiv.textContent = 'FPS: ' + fps.toFixed(0);
            lastTime = now;

            time += 0.016 * rotationSpeed; // Delta time approx 60fps

            gl.uniform1f(timeLoc, time);
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform2f(mouseLoc, rotation.y, rotation.x); // Use rotation como mouse effective
            gl.uniform1f(qualityLoc, quality);
            gl.uniform1f(lensLoc, lensStrength);
            gl.uniform1f(accretionLoc, accretionIntensity);
            gl.uniform1i(modeLoc, projectionMode);

            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
        animate(0);
    </script>
</body>
</html>